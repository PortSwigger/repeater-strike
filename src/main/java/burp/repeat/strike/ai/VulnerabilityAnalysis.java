package burp.repeat.strike.ai;
import burp.api.montoya.http.message.HttpRequestResponse;
import burp.api.montoya.http.message.requests.HttpRequest;
import burp.api.montoya.http.message.responses.HttpResponse;
import burp.repeat.strike.RepeatStrikeExtension;
import burp.repeat.strike.proxy.AnalyseProxyHistory;
import burp.repeat.strike.utils.StrikeRulesUtils;
import burp.repeat.strike.utils.Utils;
import org.json.JSONArray;
import org.json.JSONObject;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;

import static burp.repeat.strike.RepeatStrikeExtension.*;
import static burp.repeat.strike.proxy.AnalyseProxyHistory.makeRequest;
import static burp.repeat.strike.utils.Utils.generatePattern;

public class VulnerabilityAnalysis {
    public static JSONObject analyseForRegex(JSONObject baseParam, HttpRequest[] requests, HttpResponse[] responses) {
        try {
            String[] wordList = repeatStrikeTab.getWordList();
            AI ai = new AI();
            ai.setBypassRateLimit(true);
            ai.setSystemMessage("""
                You are a web security expert.
                You are given multiple HTTP requests, HTTP responses, and a JSON array of probes.
                Do not output markdown. Your response can only be a JSON Object with the following structure:
                {
                  //probesToUse should stay the same
                  "probesToUse":"""+baseParam.getJSONArray("values").toString().replace("\\/","/")+"""
                  "responseRegexes": [["RegexToFindVulnerabilityInResponse1","RegexToFindVulnerabilityInResponse1"], ["RegexToFindVulnerabilityInResponse2","RegexToFindVulnerabilityInResponse2"] ...]
                  "mutatedProbesToUse": [],
                  //mutatedResponsesRegexes should look for the vulnerability being tested by the mutated probes
                  //This will be completely different than the responseRegexes.
                  "mutatedResponsesRegexes": []
                }
                Look at each request and response given and identify the value that they are testing for.
                The number of probes should match the response regexes arrays.
                The response regexes should be used to find the original response, you can use more than one regex if it helps find the response.
                You shouldn't change the original probes.
                *important* After you've analysed the probes and response regexes you should create 10 additional ones and mutate the probes and add more regex to match the speculated data these should be placed in the mutated probes and mutated regex responses.
                Generate regex patterns or example data that match the structure and format of the response, without including real or example user-specific data such as names, tokens, emails, or IDs.                
                """ + (wordList.length > 0 ? "The user has also supplied a word list that can help when generating mutated probes. You should always use this wordlist when generating mutated probes." : "") + """              
                Strict requirements:
                    - Output only a JSON object as described.
                    - Do not output any Markdown.
                    - Do not include any explanations, backticks, syntax highlighting, code fences, or any text outside the JSON object.
                    - Your output must start immediately with { and must end after the closing }.
                    - Use the decoded probe when analysing the response
                    - Checking the response with less than 5 characters is unlikely to work. You should ensure your check is longer than 5 characters.
                    - Mutate the data with more probes and response regexes and place them in the mutatedProbesToUse and mutatedResponsesRegexes array
                    - Make sure you validate the regexes to ensure they are valid.
                    - The probes shouldn't contain the name of the parameter just the value
                    - probesToUse should stay the same any mutated values should go in mutatedProbesToUse
                    - The mutated probes shouldn't contain the name of the parameter just the value
            """);
            String prompt = Utils.getRequestsAndResponsesPrompt(requests, responses);
            if(wordList.length > 0){
                prompt += "\n\nWordList:" + String.join("\n", wordList);
            }
            ai.setPrompt(prompt);
            ai.setTemperature(1.0);
            String aiResponse = ai.execute();
            return new JSONObject(aiResponse.trim());
        } catch (Throwable throwable) {
            StringWriter writer = new StringWriter();
            throwable.printStackTrace(new PrintWriter(writer));
            api.logging().logToError(writer.toString());
        }
        return null;
    }

    public static boolean isVulnerable(JSONObject analysis, HttpRequest request, HttpResponse response, String vulnerabilityClass, String paramType, String paramName, boolean sendToOrganizer) {
        try {
            JSONArray probes = analysis.getJSONArray("probesToUse");
            JSONArray responseRegexes = analysis.getJSONArray("responseRegexes");
            return tryProbes(probes, responseRegexes, request, null, vulnerabilityClass, paramType, paramName, sendToOrganizer, true, null);
        } catch (PatternSyntaxException e) {
            return false;
        } catch(Throwable e) {
            api.logging().logToOutput(e.toString());
        }
        return false;
    }

    public static boolean checkRegexes(JSONArray originalResponseRegexes, HttpResponse response, JSONArray regexes, boolean allShouldMatch) {
        String strToMatch = response.toString();
        if(originalResponseRegexes != null) {
            for (int i = 0; i < originalResponseRegexes.length(); i++) {
                int baseMatches = 0;
                JSONArray baseRegexes = originalResponseRegexes.getJSONArray(i);
                for(int j = 0; j < baseRegexes.length(); j++) {
                    String regex = baseRegexes.getString(j);
                    Pattern pattern = generatePattern(regex);
                    if (pattern.matcher(response.toString()).find()) {
                        baseMatches++;
                    }
                }
                if(baseMatches == baseRegexes.length()) {
                    return false;
                }
            }
        }
        int foundMatches = 0;
        for (int i = 0; i < regexes.length(); i++) {
            try {
                String regex = regexes.getString(i);
                Pattern pattern = generatePattern(regex);

                if (pattern.matcher(strToMatch).find()) {
                    foundMatches++;
                }
            } catch (Throwable e) {
                api.logging().logToError(e.toString());
            }
        }
        if(allShouldMatch && foundMatches == regexes.length()) {
            return true;
        } else if(!allShouldMatch && regexes.length() > 1 && foundMatches > 1) {
            return true;
        } else {
            return !allShouldMatch && regexes.length() == 1 && foundMatches >= 1;
        }
    }

    public static boolean tryProbes(JSONArray probes, JSONArray responseRegexes, HttpRequest baseRequest, HttpResponse baseResponse, String vulnerabilityClass, String paramType, String paramName, boolean sendToOrganizer, boolean allShouldMatch, JSONArray originalResponseRegexes) {
        ArrayList<HttpRequestResponse> requestResponses = new ArrayList<>();
        int vulnerableCount = 0;
        ArrayList<String> paramValues = new ArrayList<>();
        for (int i = 0; i < probes.length(); i++) {
            String paramValue = probes.getString(i);
            if(paramType.equalsIgnoreCase("path") && !paramValue.startsWith("/")) {
                String existingPath = baseRequest.pathWithoutQuery();
                paramValue = existingPath.replaceFirst("/\\d+", "/" + paramValue);
            }
            HttpRequestResponse requestResponse = makeRequest(baseRequest, paramType, paramName, paramValue);
            if(requestResponse != null && requestResponse.response() != null) {
                HttpResponse response = requestResponse.response();
                JSONArray regexes = responseRegexes.getJSONArray(i);

                if(checkRegexes(originalResponseRegexes, response, regexes, allShouldMatch)) {
                    requestResponses.add(requestResponse);
                    paramValues.add(paramValue);
                    vulnerableCount++;
                }
            }
        }
        if((allShouldMatch && vulnerableCount == probes.length()) || (vulnerableCount > 0 && !allShouldMatch)) {
            if(sendToOrganizer) {
                for(int i=0; i<requestResponses.size(); i++) {
                    HttpRequestResponse requestResponse = requestResponses.get(i);
                    String notes = (i + 1) + " of " + requestResponses.size() + " - " + vulnerabilityClass;
                    notes += "\nParam type: " + paramType;
                    if(!paramType.equalsIgnoreCase("path")) {
                        notes += "\nParam name: " + paramName;
                    }
                    notes += "\nProbe:" + paramValues.get(i);
                    requestResponse.annotations().setNotes(notes);
                    api.organizer().sendToOrganizer(requestResponse);
                }
            }
            return true;
        }
        return false;
    }

    public static void generateStrikeRule(HttpRequest[] requests, HttpResponse[] responses, VulnerabilityScanType scanType, boolean shouldPromptToSave) {
            RepeatStrikeExtension.executorService.submit(() -> {
                try {
                    final String successMessage = "Strike Rule reproduced.";
                    final String errorMessage = "Failed to reproduce Strike Rule.";
                    if(scanType == VulnerabilityScanType.Regex) {
                        JSONObject param = IdentifyPayload.identify(requests, responses);
                        if(param != null) {
                            repeatStrikePanel.setStatus("Analysing with regex method", false);
                            JSONObject analysis = analyseForRegex(param, requests, responses);
                            if (analysis != null && isVulnerable(analysis, requests[0], responses[0], param.getString("vulnerabilityClass"), param.getString("type"), param.getString("name"), false)) {
                                api.logging().logToOutput(successMessage);
                                repeatStrikePanel.setStatus(successMessage, false);
                                JSONObject lastStrikeRuleRan = new JSONObject();
                                lastStrikeRuleRan.put("analysis", analysis);
                                lastStrikeRuleRan.put("param", param);
                                lastStrikeRuleRan.put("type", VulnerabilityScanType.Regex.name());
                                if(shouldPromptToSave && StrikeRulesUtils.saveGeneratedStrikeRule(lastStrikeRuleRan)) {
                                    Utils.resetHistory(false);
                                    AnalyseProxyHistory.analyseWithRegex(lastStrikeRuleRan.getJSONObject("analysis"), lastStrikeRuleRan.getJSONObject("param"));
                                }
                                if(!shouldPromptToSave) {
                                    AnalyseProxyHistory.analyseWithRegex(lastStrikeRuleRan.getJSONObject("analysis"), lastStrikeRuleRan.getJSONObject("param"));
                                }
                            } else {
                                api.logging().logToOutput(errorMessage);
                                repeatStrikePanel.setStatus(errorMessage, true);
                            }
                        }
                    }
                } catch(Throwable throwable) {
                    StringWriter writer = new StringWriter();
                    throwable.printStackTrace(new PrintWriter(writer));
                    api.logging().logToError(writer.toString());
                }
            });
    }
}
