package burp.repeat.strike.ai;
import burp.api.montoya.http.message.requests.HttpRequest;
import burp.api.montoya.http.message.responses.HttpResponse;
import burp.repeat.strike.RepeatStrikeExtension;
import burp.repeat.strike.proxy.AnalyseProxyHistory;
import burp.repeat.strike.settings.InvalidTypeSettingException;
import burp.repeat.strike.settings.UnregisteredSettingException;
import burp.repeat.strike.utils.Utils;
import org.json.JSONObject;

import javax.swing.*;
import java.io.PrintWriter;
import java.io.StringWriter;

import static burp.repeat.strike.RepeatStrikeExtension.api;

public class VulnerabilityAnalysis {
    public static Object compileScanCheck(String code) {
        Class<?> scanCheck = api.utilities().javaCompilationUtils().compileClass(code);
        return api.utilities().javaCompilationUtils().createInstance(scanCheck);
    }
    public static String getDescription(Object scanCheck) {
        return (String) api.utilities().javaCompilationUtils().invokeMethod(scanCheck, "getShortDescription");
    }
    public static boolean isVulnerable(Object scanCheck, HttpResponse response) {
        return (boolean) api.utilities().javaCompilationUtils().invokeMethod(scanCheck, "isVulnerable", response);
    }
    public static String getRequestProbe(Object scanCheck) {
        return (String) api.utilities().javaCompilationUtils().invokeMethod(scanCheck, "getRequestProbe");
    }
    public static Object analyse(JSONObject baseParam, HttpRequest request, HttpResponse response) {
        try {
            final String imports = """                 
            import burp.api.montoya.internal.ObjectFactoryLocator;
            import java.time.ZonedDateTime;
            import java.util.Optional;
            import burp.api.montoya.http.message.responses.HttpResponse;
            import burp.api.montoya.core.ByteArray;
            import burp.api.montoya.core.Marker;
            import burp.api.montoya.http.message.Cookie;
            import burp.api.montoya.http.message.HttpHeader;
            import burp.api.montoya.http.message.HttpMessage;
            import burp.api.montoya.http.message.MimeType;
            import burp.api.montoya.http.message.responses.analysis.Attribute;
            import burp.api.montoya.http.message.responses.analysis.AttributeType;
            import burp.api.montoya.http.message.responses.analysis.KeywordCount;
            import burp.api.montoya.internal.ObjectFactoryLocator;
            import java.util.List;
            import java.util.regex.Pattern;
            """;
            boolean debugAi;
            try {
                debugAi = RepeatStrikeExtension.generalSettings.getBoolean("debugAi");
            } catch (UnregisteredSettingException | InvalidTypeSettingException e) {
                api.logging().logToError("Error loading settings:" + e);
                throw new RuntimeException(e);
            }

            final Vulnerability vulnerabilityClass = Vulnerability.valueOf(baseParam.getString("vulnerabilityClass"));
            final String basePrompt = """
                    You are a web security expert.
                    You are given an HTTP request, HTTP response, and a base value.
                    Your task is to output a single Java class that uses the response to detect the vulnerability being tested.
                    The vulnerability being tested is\s"""+vulnerabilityClass.getLabel()+"\n";
            final String codePrompt = """                    
                    Strict requirements:
                    - Output only raw Java code.
                    - Do not output any Markdown.
                    - Do not include any explanations, backticks, syntax highlighting, code fences, or any text outside the Java code.
                    - Your output must start immediately with public class ScanCheck { and must end after the closing }.
                    - Use the decoded probe when analysing the response
                    - When designing your isVulnerable method you should avoid using existing text in the response.
                    - Checking the response with less than 5 characters is unlikely to work. You should ensure your check is longer than 5 characters.
                    
                    //Your class uses the following interfaces:
                    public interface HttpResponse {
                        short statusCode();
                   
                        String reasonPhrase();
                    
                        List<Cookie> cookies();
                    
                        Cookie cookie(String var1);
                    
                        String cookieValue(String var1);
                    
                        boolean hasCookie(String var1);
                    
                        boolean hasCookie(Cookie var1);
                    
                        MimeType mimeType();
                    
                        MimeType statedMimeType();
                    
                        MimeType inferredMimeType();
                    
                        boolean hasHeader(HttpHeader var1);
                    
                        boolean hasHeader(String var1);
                    
                        boolean hasHeader(String var1, String var2);
                    
                        HttpHeader header(String var1);
                    
                        String headerValue(String var1);

                        List<HttpHeader> headers();
                    
                        String httpVersion();
                    
                        int bodyOffset();
                    
                        ByteArray body();
                    
                        String bodyToString();
                    
                        boolean contains(String var1, boolean var2);
                    
                        boolean contains(Pattern var1);
                    
                        ByteArray toByteArray();
                    
                        String toString();
                    }
                    
                    public interface HttpHeader {
                        String name();
                    
                        String value();
                    
                        String toString();
                    }
                    
                    public enum MimeType {
                        NONE("none"),
                        UNRECOGNIZED("unrecognized content"),
                        AMBIGUOUS("ambiguous"),
                        HTML("HTML"),
                        PLAIN_TEXT("plain text"),
                        CSS("CSS"),
                        SCRIPT("script"),
                        JSON("JSON"),
                        RTF("RTF"),
                        XML("XML"),
                        YAML("YAML"),
                        IMAGE_UNKNOWN("an unknown image type"),
                        IMAGE_JPEG("a JPEG image"),
                        IMAGE_GIF("a GIF image"),
                        IMAGE_PNG("a PNG image"),
                        IMAGE_BMP("a BMP image"),
                        IMAGE_TIFF("a TIFF image"),
                        IMAGE_SVG_XML("a SVG image"),
                        SOUND("sound"),
                        VIDEO("video"),
                        APPLICATION_FLASH("a flash object"),
                        APPLICATION_UNKNOWN("an unknown application type"),
                        FONT_WOFF("a WOFF font file"),
                        FONT_WOFF2("a WOFF2 font file"),
                        LEGACY_SER_AMF("");
                    
                        private final String description;
                    
                        private MimeType(String description) {
                            this.description = description;
                        }
                    
                        public String description() {
                            return this.description;
                        }
                    }
                    
                    public interface Cookie {
                        String name();
                    
                        String value();
                    
                        String domain();
                    
                        String path();
                    
                        Optional<ZonedDateTime> expiration();
                    }
                    
                    The Java class must have exactly this structure:
                    public class ScanCheck {
                        public boolean isVulnerable(HttpResponse response) {
                            // code to detect vulnerability here
                        }
                        public String getRequestProbe() {
                            return "exampleProbe123";
                            // You should return a probe that tests for this vulnerability.
                            // Note this should just be the payload
                            // The payload should emulate the original encoding
                        }
                        public String getShortDescription() {
                            // return a string that briefly describes the vulnerability class
                        }
                    }
                    """;
            String vulnerabilityPrompt = "";
            switch (vulnerabilityClass) {
                case Vulnerability.XSS -> {
                    vulnerabilityPrompt = """
                       - Note X-Xss-Protection response header is irrelevant now and is not used by any modern browser. You should not use it for any analysis.\n
                    """;
                }
                case Vulnerability.HTTP_RESPONSE_SPLITTING -> {
                    vulnerabilityPrompt = """
                        - Do not look inside parsed Cookie objects when searching for CRLFs.
                        - When looking for CSLFs used the response headers as a whole, you can use the following code to get all headers:
                          String allHeaders = response.toString().substring(0, response.bodyOffset);
                        \n
                    """;
                }
                case Vulnerability.SQLI -> {}
                case Vulnerability.SSRF -> {}
                case Vulnerability.CSRF -> {}
                case Vulnerability.LFI -> {}
                case Vulnerability.RFI -> {}
                case Vulnerability.IDOR -> {}
                case Vulnerability.PATH_TRAVERSAL -> {}
                case Vulnerability.CLICKJACKING -> {
                    vulnerabilityPrompt = """
                        
                    """;
                }
                case Vulnerability.COMMAND_INJECTION -> {}
                case Vulnerability.WEB_CACHE_DECEPTION -> {}
                case Vulnerability.OPEN_REDIRECT -> {}
                case Vulnerability.HTTP_PARAMETER_POLLUTION -> {}
                case Vulnerability.TEMPLATE_INJECTION -> {}
                case Vulnerability.ACCOUNT_ENUMERATION -> {}
                case Vulnerability.BROKEN_ACCESS_CONTROL -> {}
                case Vulnerability.BROKEN_AUTHENTICATION -> {}
                case Vulnerability.BUSINESS_LOGIC_FLAW -> {}
                case Vulnerability.CORS_MISCONFIGURATION -> {}
                case Vulnerability.DESERIALIZATION -> {}
                case Vulnerability.EXPRESSION_INJECTION -> {}
                case Vulnerability.HOST_HEADER_INJECTION -> {}
                case Vulnerability.JWT_NONE_ALGORITHM -> {}
                case Vulnerability.LOGIC_ABUSE -> {}
                case Vulnerability.PROTOTYPE_POLLUTION -> {}
                case Vulnerability.REDOS -> {}
                case Vulnerability.SESSION_FIXATION -> {}
                case Vulnerability.SESSION_MISMANAGEMENT -> {}
            }

            AI ai = new AI();
            ai.setBypassRateLimit(true);
            ai.setSystemMessage(basePrompt + vulnerabilityPrompt + codePrompt);
            JSONObject requestJSON = new JSONObject();
            requestJSON.put("request", Utils.truncateRequest(request));
            JSONObject responseJSON = new JSONObject();
            responseJSON.put("response", Utils.truncateResponse(response));
            JSONObject baseValueJSON = new JSONObject();
            baseValueJSON.put("baseValue", baseParam.getString("value"));
            ai.setPrompt("Request:\n"+requestJSON+"\n\nResponse:\n"+responseJSON+"\n\nBase value:"+baseValueJSON);
            ai.setTemperature(1.0);
            if(debugAi) {
                api.logging().logToOutput("Sending information to the AI");
                api.logging().logToOutput(ai.getSystemMessage()+ai.getPrompt());
            }
            String aiResponse = ai.execute();
            return compileScanCheck(imports + aiResponse);
        } catch (Throwable throwable) {
            StringWriter writer = new StringWriter();
            throwable.printStackTrace(new PrintWriter(writer));
            api.logging().logToError(writer.toString());
        }
        return null;
    }
    public static void check(HttpRequest request, HttpResponse response) {
        RepeatStrikeExtension.executorService.submit(() -> {
            if(!request.isInScope()) {
                JOptionPane.showMessageDialog(null, "This request is not in scope");
                return;
            }
            JSONObject param = IdentifyPayload.identify(request);
            if(param != null) {
                Object scanCheck = VulnerabilityAnalysis.analyse(param, request, response);

                if(scanCheck != null && isVulnerable(scanCheck, response)) {
                    api.logging().logToOutput("Found vulnerability. Now scanning proxy history.");
                    AnalyseProxyHistory.analyse(scanCheck, request);
                } else {
                    api.logging().logToOutput("No vulnerability found.");
                }
            }
        });
    }
}
