package burp.repeat.strike.ai;
import burp.api.montoya.http.message.requests.HttpRequest;
import burp.api.montoya.http.message.responses.HttpResponse;
import burp.repeat.strike.RepeatStrikeExtension;
import burp.repeat.strike.settings.InvalidTypeSettingException;
import burp.repeat.strike.settings.UnregisteredSettingException;
import burp.repeat.strike.utils.Utils;
import org.json.JSONObject;
import java.io.PrintWriter;
import java.io.StringWriter;

import static burp.repeat.strike.RepeatStrikeExtension.api;

public class VulnerabilityAnalysis {
    public static Object compileScanCheck(String code) {
        Class<?> calc = api.utilities().javaCompilationUtils().compileClass(code);
        return api.utilities().javaCompilationUtils().createInstance(calc);
    }
    public static boolean isVulnerable(Object scanCheck, HttpResponse response) {
        return (boolean) api.utilities().javaCompilationUtils().invokeMethod(scanCheck, "isVulnerable", response);
    }
    public static String getRequestProbe(Object scanCheck) {
        return (String) api.utilities().javaCompilationUtils().invokeMethod(scanCheck, "getRequestProbe");
    }
    public static Object analyse(JSONObject baseParam, HttpRequest request, HttpResponse response) {
        try {
            String imports = """               
            import burp.api.montoya.internal.ObjectFactoryLocator;
            import java.time.ZonedDateTime;
            import java.util.Optional;
            import burp.api.montoya.http.message.responses.HttpResponse;
            import burp.api.montoya.core.ByteArray;
            import burp.api.montoya.core.Marker;
            import burp.api.montoya.http.message.Cookie;
            import burp.api.montoya.http.message.HttpHeader;
            import burp.api.montoya.http.message.HttpMessage;
            import burp.api.montoya.http.message.MimeType;
            import burp.api.montoya.http.message.StatusCodeClass;
            import burp.api.montoya.http.message.responses.analysis.Attribute;
            import burp.api.montoya.http.message.responses.analysis.AttributeType;
            import burp.api.montoya.http.message.responses.analysis.KeywordCount;
            import burp.api.montoya.internal.ObjectFactoryLocator;
            import java.util.List;
            import java.util.regex.Pattern;
            """;
            boolean debugAi;
            try {
                debugAi = RepeatStrikeExtension.generalSettings.getBoolean("debugAi");
            } catch (UnregisteredSettingException | InvalidTypeSettingException e) {
                api.logging().logToError("Error loading settings:" + e);
                throw new RuntimeException(e);
            }
            AI ai = new AI();
            ai.setBypassRateLimit(true);
            ai.setSystemMessage("""
                    You are a web security expert.
                    You are given an HTTP request, HTTP response, and a base value.
                    Your task is to output a single Java class that uses the response to detect the vulnerability being tested.
                    Strict requirements:
                    - Output only raw Java code.
                    - Do not output any Markdown.
                    - Do not include any explanations, backticks, syntax highlighting, code fences, or any text outside the Java code.
                    - Your output must start immediately with public class ScanCheck { and must end after the closing }.
                    - Do not look inside parsed Cookie objects when searching for CRLFs.
                    - When looking for CSLFs used the response headers as a whole, you can use the following code to get all headers:
                      String allHeaders = response.toString().substring(0, response.bodyOffset);
                    - Use the decoded probe when analysing the response
                    - When designing your isVulnerable method you should avoid using existing text in the response.
                    - Note X-Xss-Protection response header is irrelevant now and is not used by any modern browser. You should not use it for any analysis.
                    - Checking the response with less than 5 characters is unlikely to work. You should ensure your check is longer than 5 characters.
                    - Note if you are not testing for XSS or CSS injection CSP is irrelevant and should not be included in your analysis.                    
                    
                    //HttpResponse has the following interfaces:
                    public interface HttpHeader {
                        String name();
                    
                        String value();
                    
                        String toString();
                    
                        static HttpHeader httpHeader(String name, String value) {
                            return ObjectFactoryLocator.FACTORY.httpHeader(name, value);
                        }
                    
                        static HttpHeader httpHeader(String header) {
                            return ObjectFactoryLocator.FACTORY.httpHeader(header);
                        }
                    }
                    
                    public enum MimeType {
                        NONE("none"),
                        UNRECOGNIZED("unrecognized content"),
                        AMBIGUOUS("ambiguous"),
                        HTML("HTML"),
                        PLAIN_TEXT("plain text"),
                        CSS("CSS"),
                        SCRIPT("script"),
                        JSON("JSON"),
                        RTF("RTF"),
                        XML("XML"),
                        YAML("YAML"),
                        IMAGE_UNKNOWN("an unknown image type"),
                        IMAGE_JPEG("a JPEG image"),
                        IMAGE_GIF("a GIF image"),
                        IMAGE_PNG("a PNG image"),
                        IMAGE_BMP("a BMP image"),
                        IMAGE_TIFF("a TIFF image"),
                        IMAGE_SVG_XML("a SVG image"),
                        SOUND("sound"),
                        VIDEO("video"),
                        APPLICATION_FLASH("a flash object"),
                        APPLICATION_UNKNOWN("an unknown application type"),
                        FONT_WOFF("a WOFF font file"),
                        FONT_WOFF2("a WOFF2 font file"),
                        LEGACY_SER_AMF("");
                    
                        private final String description;
                    
                        private MimeType(String description) {
                            this.description = description;
                        }
                    
                        public String description() {
                            return this.description;
                        }
                    }
                    
                    public interface Cookie {
                        String name();
                    
                        String value();
                    
                        String domain();
                    
                        String path();
                    
                        Optional<ZonedDateTime> expiration();
                    }
                    
                    public enum StatusCodeClass {
                        CLASS_1XX_INFORMATIONAL_RESPONSE(100, 200),
                        CLASS_2XX_SUCCESS(200, 300),
                        CLASS_3XX_REDIRECTION(300, 400),
                        CLASS_4XX_CLIENT_ERRORS(400, 500),
                        CLASS_5XX_SERVER_ERRORS(500, 600);
                    
                        private final int startStatusCodeInclusive;
                        private final int endStatusCodeExclusive;
                    
                        private StatusCodeClass(int startStatusCodeInclusive, int endStatusCodeExclusive) {
                            this.startStatusCodeInclusive = startStatusCodeInclusive;
                            this.endStatusCodeExclusive = endStatusCodeExclusive;
                        }
                    
                        public int startStatusCodeInclusive() {
                            return this.startStatusCodeInclusive;
                        }
                    
                        public int endStatusCodeExclusive() {
                            return this.endStatusCodeExclusive;
                        }
                    
                        public boolean contains(int statusCode) {
                            return this.startStatusCodeInclusive <= statusCode && statusCode < this.endStatusCodeExclusive;
                        }
                    }                  
                    
                    public interface HttpResponse extends HttpMessage {
                        short statusCode();
                   
                        String reasonPhrase();
                    
                        boolean isStatusCodeClass(StatusCodeClass var1);
                    
                        List<Cookie> cookies();
                    
                        Cookie cookie(String var1);
                    
                        String cookieValue(String var1);
                    
                        boolean hasCookie(String var1);
                    
                        boolean hasCookie(Cookie var1);
                    
                        MimeType mimeType();
                    
                        MimeType statedMimeType();
                    
                        MimeType inferredMimeType();                                        
                    
                        boolean hasHeader(HttpHeader var1);
                    
                        boolean hasHeader(String var1);
                    
                        boolean hasHeader(String var1, String var2);
                    
                        HttpHeader header(String var1);
                    
                        String headerValue(String var1);

                        List<HttpHeader> headers();
                    
                        String httpVersion();
                    
                        int bodyOffset();
                    
                        ByteArray body();
                    
                        String bodyToString();                                          
                    
                        boolean contains(String var1, boolean var2);
                    
                        boolean contains(Pattern var1);
                    
                        ByteArray toByteArray();
                    
                        String toString();                                                                                     
                    }
                    
                    The Java class must have exactly this structure:
                        public class ScanCheck {                           
                            public boolean isVulnerable(HttpResponse response) {
                                // code to detect vulnerability here
                            }
                            public String getRequestProbe() {                           
                                return "exampleProbe123";
                                // You should return a probe that tests for this vulnerability.
                                // Note this should just be the payload
                            }
                        }                                           
                    """);
            JSONObject requestJSON = new JSONObject();
            requestJSON.put("request", Utils.truncateRequest(request));
            JSONObject responseJSON = new JSONObject();
            responseJSON.put("response", Utils.truncateResponse(response));
            JSONObject baseValueJSON = new JSONObject();
            baseValueJSON.put("baseValue", baseParam.getString("value"));
            ai.setPrompt("Request:\n"+requestJSON+"\n\nResponse:\n"+responseJSON+"\n\nBase value:"+baseValueJSON);
            ai.setTemperature(1.0);
            if(debugAi) {
                api.logging().logToOutput("Sending information to the AI");
                api.logging().logToOutput(ai.getSystemMessage()+ai.getPrompt());
            }
            String aiResponse = ai.execute();
            return compileScanCheck(imports + aiResponse);
        } catch (Throwable throwable) {
            StringWriter writer = new StringWriter();
            throwable.printStackTrace(new PrintWriter(writer));
            api.logging().logToError(writer.toString());
        }
        return null;
    }
    public static void check(HttpRequest request, HttpResponse response) {
        RepeatStrikeExtension.executorService.submit(() -> {
            JSONObject param = IdentifyPayload.identify(request);
            if(param != null) {
                JSONObject criteria = ResourceOrDocument.identify(request, response);
                Object scanCheck = VulnerabilityAnalysis.analyse(param, request, response);

                if(scanCheck != null && isVulnerable(scanCheck, response)) {
                    api.logging().logToOutput("Found vulnerability. Now scanning proxy history.");
                    AnalyseProxyHistory.analyse(scanCheck, criteria, param, request, response);
                } else {
                    api.logging().logToOutput("No vulnerability found.");
                }
            }
        });
    }
}
