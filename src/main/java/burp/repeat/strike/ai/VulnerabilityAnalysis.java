package burp.repeat.strike.ai;
import burp.api.montoya.http.message.requests.HttpRequest;
import burp.api.montoya.http.message.responses.HttpResponse;
import burp.repeat.strike.RepeatStrikeExtension;
import burp.repeat.strike.settings.InvalidTypeSettingException;
import burp.repeat.strike.settings.UnregisteredSettingException;
import burp.repeat.strike.utils.Utils;
import org.json.JSONObject;

import java.io.PrintWriter;
import java.io.StringWriter;

import static burp.repeat.strike.RepeatStrikeExtension.api;

public class VulnerabilityAnalysis {
    public static Object compileScanCheck(String code) {
        Class<?> calc = api.utilities().javaCompilationUtils().compileClass(code);
        return api.utilities().javaCompilationUtils().createInstance(calc);
    }
    public static boolean isVulnerable(Object scanCheck, HttpResponse response) {
        return (boolean) api.utilities().javaCompilationUtils().invokeMethod(scanCheck, "isVulnerable", response);
    }
    public static String getRequestProbe(Object scanCheck) {
        return (String) api.utilities().javaCompilationUtils().invokeMethod(scanCheck, "getRequestProbe");
    }
    public static Object analyse(JSONObject baseParam, HttpRequest request, HttpResponse response) {
        try {
            String imports = """           
            import burp.api.montoya.http.message.responses.HttpResponse;
            import burp.api.montoya.core.ByteArray;
            import burp.api.montoya.core.Marker;
            import burp.api.montoya.http.message.Cookie;
            import burp.api.montoya.http.message.HttpHeader;
            import burp.api.montoya.http.message.HttpMessage;
            import burp.api.montoya.http.message.MimeType;
            import burp.api.montoya.http.message.StatusCodeClass;
            import burp.api.montoya.http.message.responses.analysis.Attribute;
            import burp.api.montoya.http.message.responses.analysis.AttributeType;
            import burp.api.montoya.http.message.responses.analysis.KeywordCount;
            import burp.api.montoya.internal.ObjectFactoryLocator;
            import java.util.List;
            import java.util.regex.Pattern;
            """;
            boolean debugAi;
            try {
                debugAi = RepeatStrikeExtension.generalSettings.getBoolean("debugAi");
            } catch (UnregisteredSettingException | InvalidTypeSettingException e) {
                api.logging().logToError("Error loading settings:" + e);
                throw new RuntimeException(e);
            }
            AI ai = new AI();
            ai.setBypassRateLimit(true);
            ai.setSystemMessage("""
                    You are a web security expert.
                    You are given an HTTP request, HTTP response, and a base value.
                    Your task is to output a single Java class that uses the response to detect the vulnerability being tested.
                    Strict requirements:
                    - Output only raw Java code.
                    - Do not output any Markdown.
                    - Do not include any explanations, backticks, syntax highlighting, code fences, or any text outside the Java code.
                    - Your output must start immediately with public class ScanCheck { and must end after the closing }.
                    - Do not look inside parsed Cookie objects when searching for CRLFs.
                    - When looking for CSLFs used the response headers as a whole, you can use the following code to get all headers:
                      String allHeaders = response.toString().substring(0, response.bodyOffset);
                    - Use the probe when analysing the response
                    - When designing your isVulnerable method you should avoid using existing text in the response and instead use the probe.
                    
                    //HttpResponse has the following interface:
                    public interface HttpResponse extends HttpMessage {
                        short statusCode();
                   
                        String reasonPhrase();
                    
                        boolean isStatusCodeClass(StatusCodeClass var1);
                    
                        List<Cookie> cookies();
                    
                        Cookie cookie(String var1);
                    
                        String cookieValue(String var1);
                    
                        boolean hasCookie(String var1);
                    
                        boolean hasCookie(Cookie var1);
                    
                        MimeType mimeType();
                    
                        MimeType statedMimeType();
                    
                        MimeType inferredMimeType();
                    
                        List<KeywordCount> keywordCounts(String... var1);
                    
                        List<Attribute> attributes(AttributeType... var1);
                    
                        boolean hasHeader(HttpHeader var1);
                    
                        boolean hasHeader(String var1);
                    
                        boolean hasHeader(String var1, String var2);
                    
                        HttpHeader header(String var1);
                    
                        String headerValue(String var1);

                        List<HttpHeader> headers();
                    
                        String httpVersion();
                    
                        int bodyOffset();
                    
                        ByteArray body();
                    
                        String bodyToString();
                    
                        List<Marker> markers();
                    
                        boolean contains(String var1, boolean var2);
                    
                        boolean contains(Pattern var1);
                    
                        ByteArray toByteArray();
                    
                        String toString();
                    
                        HttpResponse copyToTempFile();
                    
                        HttpResponse withStatusCode(short var1);
                    
                        HttpResponse withReasonPhrase(String var1);
                    
                        HttpResponse withHttpVersion(String var1);
                    
                        HttpResponse withBody(String var1);
                    
                        HttpResponse withBody(ByteArray var1);
                    
                        HttpResponse withAddedHeader(HttpHeader var1);
                    
                        HttpResponse withAddedHeader(String var1, String var2);
                    
                        HttpResponse withAddedHeaders(List<? extends HttpHeader> var1);
                    
                        HttpResponse withAddedHeaders(HttpHeader... var1);
                    
                        HttpResponse withUpdatedHeader(HttpHeader var1);
                    
                        HttpResponse withUpdatedHeader(String var1, String var2);
                    
                        HttpResponse withUpdatedHeaders(List<? extends HttpHeader> var1);
                    
                        HttpResponse withUpdatedHeaders(HttpHeader... var1);
                    
                        HttpResponse withRemovedHeader(HttpHeader var1);
                    
                        HttpResponse withRemovedHeader(String var1);
                    
                        HttpResponse withRemovedHeaders(List<? extends HttpHeader> var1);
                    
                        HttpResponse withRemovedHeaders(HttpHeader... var1);                                           
                    }
                    
                    The Java class must have exactly this structure:
                        public class ScanCheck {                           
                            public boolean isVulnerable(HttpResponse response) {
                                // code to detect vulnerability here
                            }
                            public String getRequestProbe() {                           
                                return "exampleProbe123";
                                // You should return a probe that tests for this vulnerability.
                                // Note this should just be the payload
                            }
                        }                                           
                    """);
            JSONObject requestJSON = new JSONObject();
            requestJSON.put("request", Utils.truncateRequest(request));
            JSONObject responseJSON = new JSONObject();
            responseJSON.put("response", Utils.truncateResponse(response));
            JSONObject baseValueJSON = new JSONObject();
            baseValueJSON.put("baseValue", baseParam.getString("value"));
            ai.setPrompt("Request:\n"+requestJSON+"\n\nResponse:\n"+responseJSON+"\n\nBase value:"+baseValueJSON);
            ai.setTemperature(1.0);
            if(debugAi) {
                api.logging().logToOutput("Sending information to the AI");
                api.logging().logToOutput(ai.getSystemMessage()+ai.getPrompt());
            }
            String aiResponse = ai.execute();
            return compileScanCheck(imports + aiResponse);
        } catch (Throwable throwable) {
            StringWriter writer = new StringWriter();
            throwable.printStackTrace(new PrintWriter(writer));
            api.logging().logToError(writer.toString());
        }
        return null;
    }
    public static void check(HttpRequest request, HttpResponse response) {
        RepeatStrikeExtension.executorService.submit(() -> {
            JSONObject param = IdentifyPayload.identify(request);
            if(param != null) {
                JSONObject criteria = ResourceOrDocument.identify(request, response);
                Object scanCheck = VulnerabilityAnalysis.analyse(param, request, response);

                if(scanCheck != null && isVulnerable(scanCheck, response)) {
                    api.logging().logToOutput("Found vulnerability. Now scanning proxy history.");
                    AnalyseProxyHistory.analyse(scanCheck, criteria, param, request, response);
                } else {
                    api.logging().logToOutput("No vulnerability found.");
                }
            }
        });
    }
}
