package burp.repeat.strike.ai;
import burp.api.montoya.http.message.HttpRequestResponse;
import burp.api.montoya.http.message.requests.HttpRequest;
import burp.api.montoya.http.message.responses.HttpResponse;
import burp.repeat.strike.RepeatStrikeExtension;
import burp.repeat.strike.diffing.RequestDiffer;
import burp.repeat.strike.proxy.AnalyseProxyHistory;
import burp.repeat.strike.settings.InvalidTypeSettingException;
import burp.repeat.strike.settings.UnregisteredSettingException;
import burp.repeat.strike.utils.Utils;
import org.json.JSONArray;
import org.json.JSONObject;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Set;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;

import static burp.repeat.strike.RepeatStrikeExtension.*;
import static burp.repeat.strike.proxy.AnalyseProxyHistory.makeRequest;
import static burp.repeat.strike.proxy.AnalyseProxyHistory.makeRequestAndVerifyUsingObject;
import static burp.repeat.strike.utils.Utils.alert;

public class VulnerabilityAnalysis {

    public static Object compileScanCheck(String code) {
        Class<?> scanCheck = api.utilities().javaCompilationUtils().compileClass(code);
        return api.utilities().javaCompilationUtils().createInstance(scanCheck);
    }
    public static String getDescription(Object scanCheck) {
        return (String) api.utilities().javaCompilationUtils().invokeMethod(scanCheck, "getShortDescription");
    }
    public static boolean didProbeWork(Object scanCheck, HttpResponse response, int probeNumber) {
        return (boolean) api.utilities().javaCompilationUtils().invokeMethod(scanCheck, "didProbeWork", response, probeNumber);
    }
    public static String[] getRequestProbes(Object scanCheck) {
        return (String[]) api.utilities().javaCompilationUtils().invokeMethod(scanCheck, "getRequestProbes");
    }
    public static JSONObject analyseForRegex(JSONObject baseParam, HttpRequest[] requests, HttpResponse[] responses) {
        try {
            AI ai = new AI();
            ai.setBypassRateLimit(true);
            ai.setSystemMessage("""
                You are a web security expert.
                You are given multiple HTTP requests, HTTP responses, and a JSON array of probes.
                Do not output markdown. Your response can only be a JSON Object with the following structure:
                {
                  "probesToUse":"""+baseParam.getJSONArray("values").toString().replace("\\/","/")+"""
                  "responseRegexes": [["RegexToFindVulnerabilityInResponse1","RegexToFindVulnerabilityInResponse1"], ["RegexToFindVulnerabilityInResponse2","RegexToFindVulnerabilityInResponse2"] ...]
                }
                Look at each request and response given and identify the value that they are testing for.
                The number of probes should match the response regexes arrays.
                The response regexes should be used to find the vulnerability, you can use more than one regex if it helps find the vulnerability in the response.                
                Strict requirements:
                    - Output only a JSON object as described.
                    - Do not output any Markdown.
                    - Do not include any explanations, backticks, syntax highlighting, code fences, or any text outside the JSON object.
                    - Your output must start immediately with { and must end after the closing }.
                    - Use the decoded probe when analysing the response
                    - Checking the response with less than 5 characters is unlikely to work. You should ensure your check is longer than 5 characters.
            """);
            ai.setPrompt(Utils.getRequestsAndResponsesAsJson(requests, responses));
            ai.setTemperature(1.0);
            String aiResponse = ai.execute();
            return new JSONObject(aiResponse.trim());
        } catch (Throwable throwable) {
            StringWriter writer = new StringWriter();
            throwable.printStackTrace(new PrintWriter(writer));
            api.logging().logToError(writer.toString());
        }
        return null;
    }

    public static String analyseForJavaScanCheck(JSONObject baseParam, HttpRequest[] requests, HttpResponse[] responses) {
        try {
            final String imports = getImports();
            final Vulnerability vulnerabilityClass = Vulnerability.valueOf(baseParam.getString("vulnerabilityClass"));
            final String basePrompt = getBasePrompt(vulnerabilityClass);
            final String codePrompt = getJavaCodePrompt();
            final String vulnerabilityPrompt = getVulnerabilityPrompt(vulnerabilityClass);

            AI ai = new AI();
            ai.setBypassRateLimit(true);
            ai.setSystemMessage(basePrompt + vulnerabilityPrompt + codePrompt);
            JSONObject baseValueJSON = new JSONObject();
            baseValueJSON.put("baseValue", baseParam.getJSONArray("values"));
            ai.setPrompt(Utils.getRequestsAndResponsesAsJson(requests, responses)+"\n\nBase value:"+baseValueJSON);
            ai.setTemperature(1.0);
            String aiResponse = ai.execute();
            return imports + aiResponse;
        } catch (Throwable throwable) {
            StringWriter writer = new StringWriter();
            throwable.printStackTrace(new PrintWriter(writer));
            api.logging().logToError(writer.toString());
        }
        return null;
    }

    private static String getImports() {
        return """                 
            import burp.api.montoya.internal.ObjectFactoryLocator;
            import java.time.ZonedDateTime;
            import java.util.Optional;
            import burp.api.montoya.http.message.responses.HttpResponse;
            import burp.api.montoya.core.ByteArray;
            import burp.api.montoya.core.Marker;
            import burp.api.montoya.http.message.Cookie;
            import burp.api.montoya.http.message.HttpHeader;
            import burp.api.montoya.http.message.HttpMessage;
            import burp.api.montoya.http.message.MimeType;
            import burp.api.montoya.http.message.responses.analysis.Attribute;
            import burp.api.montoya.http.message.responses.analysis.AttributeType;
            import burp.api.montoya.http.message.responses.analysis.KeywordCount;
            import burp.api.montoya.internal.ObjectFactoryLocator;
            import java.util.List;
            import java.util.regex.Pattern;
            """;
    }

    private static String getBasePrompt(Vulnerability vulnerabilityClass) {
        return """
                    You are a web security expert.
                    You are given multiple HTTP requests, HTTP responses, and a base value.
                    Your task is to output a single Java class that uses the response to detect the vulnerability being tested.
                    The vulnerability being tested is\s"""+vulnerabilityClass.getLabel()+"\n";
    }

    private static String getJavaCodePrompt() {
        return  """                    
                    Strict requirements:
                    - Output only raw Java code.
                    - Do not output any Markdown.
                    - Do not include any explanations, backticks, syntax highlighting, code fences, or any text outside the Java code.
                    - Your output must start immediately with public class ScanCheck { and must end after the closing }.
                    - Use the decoded probe when analysing the response
                    - When designing your didProbeWork method you should avoid using existing text in the response.
                    - Checking the response with less than 5 characters is unlikely to work. You should ensure your check is longer than 5 characters.
                    
                    //Your class uses the following interfaces:
                    public interface HttpResponse {
                        short statusCode();
                   
                        String reasonPhrase();
                    
                        List<Cookie> cookies();
                    
                        Cookie cookie(String var1);
                    
                        String cookieValue(String var1);
                    
                        boolean hasCookie(String var1);
                    
                        boolean hasCookie(Cookie var1);
                    
                        MimeType mimeType();
                    
                        MimeType statedMimeType();
                    
                        MimeType inferredMimeType();
                    
                        boolean hasHeader(HttpHeader var1);
                    
                        boolean hasHeader(String var1);
                    
                        boolean hasHeader(String var1, String var2);
                    
                        HttpHeader header(String var1);
                    
                        String headerValue(String var1);

                        List<HttpHeader> headers();
                    
                        String httpVersion();
                    
                        int bodyOffset();
                    
                        String bodyToString();
                    
                        String toString();
                    }
                    
                    public interface HttpHeader {
                        String name();
                    
                        String value();
                    
                        String toString();
                    }
                    
                    public enum MimeType {
                        NONE("none"),
                        UNRECOGNIZED("unrecognized content"),
                        AMBIGUOUS("ambiguous"),
                        HTML("HTML"),
                        PLAIN_TEXT("plain text"),
                        CSS("CSS"),
                        SCRIPT("script"),
                        JSON("JSON"),
                        RTF("RTF"),
                        XML("XML"),
                        YAML("YAML"),
                        IMAGE_UNKNOWN("an unknown image type"),
                        IMAGE_JPEG("a JPEG image"),
                        IMAGE_GIF("a GIF image"),
                        IMAGE_PNG("a PNG image"),
                        IMAGE_BMP("a BMP image"),
                        IMAGE_TIFF("a TIFF image"),
                        IMAGE_SVG_XML("a SVG image"),
                        SOUND("sound"),
                        VIDEO("video"),
                        APPLICATION_FLASH("a flash object"),
                        APPLICATION_UNKNOWN("an unknown application type"),
                        FONT_WOFF("a WOFF font file"),
                        FONT_WOFF2("a WOFF2 font file"),
                        LEGACY_SER_AMF("");
                    
                        private final String description;
                    
                        private MimeType(String description) {
                            this.description = description;
                        }
                    
                        public String description() {
                            return this.description;
                        }
                    }
                    
                    public interface Cookie {
                        String name();
                    
                        String value();
                    
                        String domain();
                    
                        String path();
                    
                        Optional<ZonedDateTime> expiration();
                    }
                    
                    The Java class must have exactly this structure:
                    public class ScanCheck {
                        public boolean didProbeWork(HttpResponse response, int probeNumber) {
                            if(probeNumber == 0) {
                                // code to detect vulnerability here                                
                            } else if(probeNumber == 1) {
                                // code to detect vulnerability here
                            }
                            // add more if statements as necessary
                        }
                        public String[] getRequestProbes() {
                            String[] probes = new String[] {
                            "exampleProbe1",//probeNumber 0
                            "exampleProbe2" //probeNumber 1
                            ... //probeNumber 2 ...
                            };
                            return probes;
                            // You should return a java array of probes that tests for this vulnerability.
                            // Note this should just be the payload
                            // It should be the parameter value and not include the parameter name
                            // The payload should emulate the original encoding
                            // The number of probes should match the probe numbers in the didProbeWork.
                            // The probe number should also match the response being analyzed.
                        }
                        public String getShortDescription() {
                            // return a string that briefly describes the vulnerability class
                        }
                    }
                    """;
    }

    private static String getVulnerabilityPrompt(Vulnerability vulnerabilityClass) {
        String vulnerabilityPrompt = "";
        switch (vulnerabilityClass) {
            case Vulnerability.XSS -> vulnerabilityPrompt = """
               - Note X-Xss-Protection response header is irrelevant now and is not used by any modern browser. You should not use it for any analysis.
               \n
            """;
            case Vulnerability.HTTP_RESPONSE_SPLITTING -> vulnerabilityPrompt = """
                - Do not look inside parsed Cookie objects when searching for CRLFs.
                - When looking for CSLFs used the response headers as a whole, you can use the following code to get all headers:
                  String allHeaders = response.toString().substring(0, response.bodyOffset);
                \n
            """;
            case Vulnerability.SQLI -> vulnerabilityPrompt = """
                - Avoid assuming all SQL injections are in parameters; consider HTTP headers or cookies too.
                - Check for delayed responses or out-of-band interactions in blind injection scenarios.
                \n
            """;
            case Vulnerability.SSRF -> vulnerabilityPrompt = """
                - Prefer checking raw request body and headers, not just parsed URL or destination.
                - Watch for SSRF via DNS rebinding or open redirects as intermediary hops.
                \n
            """;
            case Vulnerability.CSRF -> vulnerabilityPrompt = """
                - Do not assume that presence of a CSRF token means it's validated.
                - Pay attention to CORS policies and cookies with SameSite=None; they may bypass CSRF protections.
                \n
            """;
            case Vulnerability.LFI -> vulnerabilityPrompt = """
                - Inspect file-based APIs and URL parameters that touch the file system.
                - Consider common wrapper bypasses like null byte truncation or directory normalization.
                \n
            """;
            case Vulnerability.RFI -> vulnerabilityPrompt = """
                - Watch for file inclusion patterns using protocols like http:// or php://.
                - Dynamic inclusion from query parameters or external sources is a red flag.
                \n
            """;
            case Vulnerability.IDOR -> vulnerabilityPrompt = """
                - Check if authorization is enforced on object-level identifiers, not just authentication.
                - Always test numeric and UUID-based resources for predictability or exposure.
                \n
            """;
            case Vulnerability.PATH_TRAVERSAL -> vulnerabilityPrompt = """
                - Look for ../ sequences in paths and verify if server canonicalizes paths correctly.
                - Check interactions with APIs that read/write from disk or ZIP/jar extraction.
                \n
            """;
            case Vulnerability.CLICKJACKING -> vulnerabilityPrompt = """
                - Check for missing or misconfigured X-Frame-Options or CSP frame-ancestors headers.
                - Hidden or off-screen iframes can still be used in some UIs; don't rely on visibility checks.
                \n
            """;
            case Vulnerability.COMMAND_INJECTION -> vulnerabilityPrompt = """
                - Audit any concatenation or interpolation into shell/exec commands.
                - Look for calls to Runtime.exec, ProcessBuilder, or OS shell wrappers with unsanitized input.
                \n
            """;
            case Vulnerability.WEB_CACHE_DECEPTION -> vulnerabilityPrompt = """
                - Focus on URLs with misleading extensions (e.g., /profile.php/home.jpg).
                - Caching of personalized pages with static-looking URLs is the core issue.
                \n
            """;
            case Vulnerability.OPEN_REDIRECT -> vulnerabilityPrompt = """
                - Relative or absolute redirects should be checked for user-controlled values.
                - Don't ignore URL fragments or base64 encoded redirection targets.
                \n
            """;
            case Vulnerability.HTTP_PARAMETER_POLLUTION -> vulnerabilityPrompt = """
                - Check what happens when the same parameter key is repeated (e.g., ?user=1&user=2).
                - Pay attention to backend frameworks' handling of multi-value parameters.
                \n
            """;
            case Vulnerability.TEMPLATE_INJECTION -> vulnerabilityPrompt = """
                - Check template expressions in user-controlled fields (e.g., {{userInput}}).
                - Different engines have different syntaxes—test accordingly (e.g., Jinja2, Freemarker, Thymeleaf).
                \n
            """;
            case Vulnerability.ACCOUNT_ENUMERATION -> vulnerabilityPrompt = """
                - Compare login and password reset error messages and response timings.
                - Differences in HTTP status codes or headers may leak user existence.
                \n
            """;
            case Vulnerability.BROKEN_ACCESS_CONTROL -> vulnerabilityPrompt = """
                - Do not rely on UI elements to enforce access control; test APIs directly.
                - Try privilege escalation by changing roles or accessing unauthorized resources.
                \n
            """;
            case Vulnerability.BROKEN_AUTHENTICATION -> vulnerabilityPrompt = """
                - Analyze password reset, account recovery, and session persistence mechanisms.
                - Test for weak password policies, credential stuffing, or multi-factor bypasses.
                \n
            """;
            case Vulnerability.BUSINESS_LOGIC_FLAW -> vulnerabilityPrompt = """
                - Think like a user trying to abuse the workflow (e.g., skipping payment or approvals).
                - There may not be code-level bugs; the issue is in misuse of legitimate flows.
                \n
            """;
            case Vulnerability.CORS_MISCONFIGURATION -> vulnerabilityPrompt = """
                - Look for overly permissive Access-Control-Allow-Origin and credentials=true.
                - Wildcard origins with allow-credentials are invalid but often misconfigured.
                \n
            """;
            case Vulnerability.DESERIALIZATION -> vulnerabilityPrompt = """
                - Look for serialized data (Java, JSON, PHP) in cookies, body, or headers.
                - Check for gadgets or deserialization sinks like readObject() or unserialize().
                \n
            """;
            case Vulnerability.EXPRESSION_INJECTION -> vulnerabilityPrompt = """
                - Evaluate EL or OGNL injection opportunities in custom logic or templating.
                - ${...} and #{} are common signs in Java stack-based injection surfaces.
                \n
            """;
            case Vulnerability.HOST_HEADER_INJECTION -> vulnerabilityPrompt = """
                - Test how the app behaves with a custom Host header; especially in redirects or password reset emails.
                - Look at X-Forwarded-Host and related headers in proxy setups.
                \n
            """;
            case Vulnerability.JWT_NONE_ALGORITHM -> vulnerabilityPrompt = """
                - Check JWTs for 'alg' header set to 'none' or unsupported algorithms.
                - Try stripping the signature or swapping algorithms and see if it's still accepted.
                \n
            """;
            case Vulnerability.LOGIC_ABUSE -> vulnerabilityPrompt = """
                - Abuse application logic like discount stacking, quota resets, or forced race conditions.
                - Often involves using legitimate features in unexpected sequences or volumes.
                \n
            """;
            case Vulnerability.PROTOTYPE_POLLUTION -> vulnerabilityPrompt = """
                - Look for payloads that modify __proto__, constructor, or prototype keys in JSON objects.
                - Impact is usually on client-side JavaScript, especially with deep merge operations.
                \n
            """;
            case Vulnerability.REDOS -> vulnerabilityPrompt = """
                - Check for user input in regex patterns, especially with nested quantifiers.
                - Time-based fuzzing can reveal catastrophic backtracking vulnerabilities.
                \n
            """;
            case Vulnerability.SESSION_FIXATION -> vulnerabilityPrompt = """
                - See if session identifiers can be set via GET/POST and remain valid after login.
                - A session should be regenerated on privilege elevation events like login.
                \n
            """;
            case Vulnerability.SESSION_MISMANAGEMENT -> vulnerabilityPrompt = """
                - Check cookie flags: HttpOnly, Secure, SameSite.
                - Test for session timeout, invalidation after logout, and reuse of old tokens.
                \n
            """;
        }
        return vulnerabilityPrompt;
    }

    public static boolean isVulnerable(JSONObject analysis, HttpRequest request, String vulnerabilityClass, String paramType, String paramName, boolean sendToOrganizer) {
        try {
            JSONArray probes = analysis.getJSONArray("probesToUse");
            JSONArray responseRegexes = analysis.getJSONArray("responseRegexes");
            ArrayList<HttpRequestResponse> requestResponses = new ArrayList<>();
            int vulnerableCount = 0;
            for (int i = 0; i < probes.length(); i++) {
                HttpRequestResponse requestResponse = makeRequest(request, paramType, paramName, probes.getString(i));
                if(requestResponse != null && requestResponse.response() != null) {
                    requestResponses.add(requestResponse);
                    HttpResponse response = requestResponse.response();
                    String strToMatch = response.toString();
                    JSONArray regexes = responseRegexes.getJSONArray(i);
                    int foundMatches = 0;
                    for (int j = 0; j < regexes.length(); j++) {
                        String regex = regexes.getString(j);
                        if(Pattern.compile(regex, Pattern.CASE_INSENSITIVE).matcher(strToMatch).find()) {
                            foundMatches++;
                        }
                    }
                    if(foundMatches == regexes.length()) {
                        vulnerableCount++;
                    }
                }
            }
            if(vulnerableCount == probes.length()) {
                if(sendToOrganizer) {
                    for(HttpRequestResponse requestResponse : requestResponses) {
                        requestResponse.annotations().setNotes(vulnerabilityClass);
                        api.organizer().sendToOrganizer(requestResponse);
                    }
                }
                return true;
            }
        } catch (PatternSyntaxException e) {
            return false;
        } catch (UnregisteredSettingException | InvalidTypeSettingException e) {
            throw new RuntimeException(e);
        }
        return false;
    }

    public static void generateScanCheck(HttpRequest[] requests, HttpResponse[] responses, VulnerabilityScanType scanType) {
        RepeatStrikeExtension.executorService.submit(() -> {

            final String successMessage = "Scan check reproduced. Click 'Save Last Scan Check' to save it.";
            final String errorMessage = "Failed to reproduce scan check.";

            if (scanType == VulnerabilityScanType.Java) {
                JSONObject param = IdentifyPayload.identify(requests, responses);
                if(param != null) {
                    repeatStrikePanel.setStatus("Analysing with java method", false);
                    String javaCode = VulnerabilityAnalysis.analyseForJavaScanCheck(param, requests, responses);
                    Object scanCheck = compileScanCheck(javaCode);

                    String[] probes = getRequestProbes(scanCheck);
                    int probeSuccess = 0;
                    for (int probeNumber = 0; probeNumber < probes.length; probeNumber++) {
                        HttpRequestResponse requestResponse = null;
                        try {
                            requestResponse = makeRequestAndVerifyUsingObject(HttpRequestResponse.httpRequestResponse(requests[probeNumber], responses[probeNumber]), param.getString("type"), param.getString("name"), probes[probeNumber], probeNumber, scanCheck);
                        } catch (UnregisteredSettingException | InvalidTypeSettingException e) {
                            throw new RuntimeException(e);
                        }
                        if (requestResponse != null) {
                            probeSuccess++;
                        }
                    }
                    if (probeSuccess == probes.length) {
                        api.logging().logToOutput(successMessage);
                        repeatStrikePanel.setStatus(successMessage, false);
                        lastScanCheckRan = new JSONObject();
                        lastScanCheckRan.put("param", param);
                        lastScanCheckRan.put("type", VulnerabilityScanType.Java.name());
                        lastScanCheckRan.put("code", javaCode);
                    } else {
                        api.logging().logToOutput(errorMessage);
                        repeatStrikePanel.setStatus(errorMessage, true);
                    }
                }
            } else if(scanType == VulnerabilityScanType.Regex) {
                JSONObject param = IdentifyPayload.identify(requests, responses);
                if(param != null) {
                    repeatStrikePanel.setStatus("Analysing with regex method", false);
                    JSONObject analysis = analyseForRegex(param, requests, responses);
                    if (analysis != null && isVulnerable(analysis, requests[0], param.getString("vulnerabilityClass"), param.getString("type"), param.getString("name"), false)) {
                        api.logging().logToOutput(successMessage);
                        repeatStrikePanel.setStatus(successMessage, false);
                        lastScanCheckRan = new JSONObject();
                        lastScanCheckRan.put("analysis", analysis);
                        lastScanCheckRan.put("param", param);
                        lastScanCheckRan.put("type", VulnerabilityScanType.Regex.name());
                    } else {
                        api.logging().logToOutput(errorMessage);
                        repeatStrikePanel.setStatus(errorMessage, true);
                    }
                }
            } else if(scanType == VulnerabilityScanType.DiffingNonAi) {
                repeatStrikePanel.setStatus("Analysing with diffing method", false);
                JSONArray headersAndParameters = RequestDiffer.generateHeadersAndParametersJson(requests);
                JSONObject param = headersAndParameters.getJSONObject(headersAndParameters.length() - 1);
                for (HttpRequest request : requests) {
                    String value = Utils.getParameterValue(request, param.getString("name"), param.getString("type"));
                    HttpRequestResponse requestResponse = null;
                    try {
                        requestResponse = makeRequest(request, param.getString("type"), param.getString("name"), value);
                    } catch (UnregisteredSettingException | InvalidTypeSettingException e) {
                        throw new RuntimeException(e);
                    }
                    if (requestResponse != null) {
                        short statusCode = requestResponse.response().statusCode();
                        if (statusCode != 200) {
                            api.logging().logToOutput(successMessage);
                            repeatStrikePanel.setStatus(successMessage, false);
                            lastScanCheckRan = new JSONObject();
                            lastScanCheckRan.put("statusCode", statusCode);
                            lastScanCheckRan.put("value", value);
                            lastScanCheckRan.put("type", VulnerabilityScanType.DiffingNonAi.name());
                            break;
                        }
                    }
                }
            }
        });
    }
}
