package burp.repeat.strike.ai;

import burp.api.montoya.http.message.requests.HttpRequest;
import burp.api.montoya.http.message.responses.HttpResponse;
import burp.repeat.strike.RepeatStrikeExtension;
import burp.repeat.strike.settings.InvalidTypeSettingException;
import burp.repeat.strike.settings.UnregisteredSettingException;
import burp.repeat.strike.utils.Utils;
import org.json.JSONObject;

import java.io.PrintWriter;
import java.io.StringWriter;

import static burp.repeat.strike.RepeatStrikeExtension.api;

public class VulnerabilityAnalysis {
    public static JSONObject analyse(HttpRequest request, HttpResponse response) {
        try {
            boolean debugAi;
            try {
                debugAi = RepeatStrikeExtension.generalSettings.getBoolean("debugAi");
            } catch (UnregisteredSettingException | InvalidTypeSettingException e) {
                api.logging().logToError("Error loading settings:" + e);
                throw new RuntimeException(e);
            }
            AI ai = new AI();
            ai.setBypassRateLimit(true);
            ai.setSystemMessage("""
                        You are a web security expert.
                        You are going to be given a request and response.
                        Do not output markdown. Your response can only be a JSON Object with the following structure:
                        {
                          "didAttackWork": "Yes" | "No"
                          "probeToUse": "<probe>",
                          "responseRegex": "<RegExp>"
                        }
                        Look at the request and response and determine if you think the request and response resulted in a vulnerability.
                        In the "didAttackWork" property put "Yes" or "No" if you think the attack worked.
                        The "probeToUse" property should contain a payload that helps detect the vulnerability and should be matched in the response regex.
                        The response regex should be a string that helps detect if the probe worked.
                        """);
            JSONObject requestJSON = new JSONObject();
            requestJSON.put("request", Utils.truncateRequest(request));
            JSONObject responseJSON = new JSONObject();
            responseJSON.put("response", Utils.truncateResponse(response));
            ai.setPrompt("Request:\n"+requestJSON+"\n\nResponse:\n"+responseJSON);
            ai.setTemperature(1.0);
            if(debugAi) {
                api.logging().logToOutput("Sending information to the AI");
                api.logging().logToOutput(ai.getSystemMessage()+ai.getPrompt());
            }
            String aiResponse = ai.execute();
            return new JSONObject(aiResponse.trim());
        } catch (Throwable throwable) {
            StringWriter writer = new StringWriter();
            throwable.printStackTrace(new PrintWriter(writer));
            api.logging().logToError(writer.toString());
        }
        return null;
    }
    public static void check(HttpRequest request, HttpResponse response) {
        RepeatStrikeExtension.executorService.submit(() -> {
            JSONObject param = IdentifyPayload.identify(request);
            if(param != null) {
                JSONObject criteria = ResourceOrDocument.identify(request, response);
                JSONObject analysis = VulnerabilityAnalysis.analyse(request, response);

                if(analysis != null && analysis.getString("didAttackWork").equalsIgnoreCase("Yes")) {
                    AnalyseProxyHistory.analyse(analysis, criteria, param, request, response);
                }
            }
        });
    }
}
