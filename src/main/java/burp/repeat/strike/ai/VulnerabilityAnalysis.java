package burp.repeat.strike.ai;
import burp.api.montoya.http.message.requests.HttpRequest;
import burp.api.montoya.http.message.responses.HttpResponse;
import burp.repeat.strike.RepeatStrikeExtension;
import burp.repeat.strike.proxy.AnalyseProxyHistory;
import burp.repeat.strike.settings.InvalidTypeSettingException;
import burp.repeat.strike.settings.UnregisteredSettingException;
import burp.repeat.strike.utils.Utils;
import org.json.JSONObject;

import javax.swing.*;
import java.io.PrintWriter;
import java.io.StringWriter;

import static burp.repeat.strike.RepeatStrikeExtension.api;

public class VulnerabilityAnalysis {
    public static Object compileScanCheck(String code) {
        Class<?> scanCheck = api.utilities().javaCompilationUtils().compileClass(code);
        return api.utilities().javaCompilationUtils().createInstance(scanCheck);
    }
    public static String getDescription(Object scanCheck) {
        return (String) api.utilities().javaCompilationUtils().invokeMethod(scanCheck, "getShortDescription");
    }
    public static boolean isVulnerable(Object scanCheck, HttpResponse response) {
        return (boolean) api.utilities().javaCompilationUtils().invokeMethod(scanCheck, "isVulnerable", response);
    }
    public static String getRequestProbe(Object scanCheck) {
        return (String) api.utilities().javaCompilationUtils().invokeMethod(scanCheck, "getRequestProbe");
    }
    public static Object analyse(JSONObject baseParam, HttpRequest request, HttpResponse response) {
        try {
            final String imports = """                 
            import burp.api.montoya.internal.ObjectFactoryLocator;
            import java.time.ZonedDateTime;
            import java.util.Optional;
            import burp.api.montoya.http.message.responses.HttpResponse;
            import burp.api.montoya.core.ByteArray;
            import burp.api.montoya.core.Marker;
            import burp.api.montoya.http.message.Cookie;
            import burp.api.montoya.http.message.HttpHeader;
            import burp.api.montoya.http.message.HttpMessage;
            import burp.api.montoya.http.message.MimeType;
            import burp.api.montoya.http.message.responses.analysis.Attribute;
            import burp.api.montoya.http.message.responses.analysis.AttributeType;
            import burp.api.montoya.http.message.responses.analysis.KeywordCount;
            import burp.api.montoya.internal.ObjectFactoryLocator;
            import java.util.List;
            import java.util.regex.Pattern;
            """;
            boolean debugAi;
            try {
                debugAi = RepeatStrikeExtension.generalSettings.getBoolean("debugAi");
            } catch (UnregisteredSettingException | InvalidTypeSettingException e) {
                api.logging().logToError("Error loading settings:" + e);
                throw new RuntimeException(e);
            }

            final Vulnerability vulnerabilityClass = Vulnerability.valueOf(baseParam.getString("vulnerabilityClass"));
            final String basePrompt = """
                    You are a web security expert.
                    You are given an HTTP request, HTTP response, and a base value.
                    Your task is to output a single Java class that uses the response to detect the vulnerability being tested.
                    The vulnerability being tested is\s"""+vulnerabilityClass.getLabel()+"\n";
            final String codePrompt = """                    
                    Strict requirements:
                    - Output only raw Java code.
                    - Do not output any Markdown.
                    - Do not include any explanations, backticks, syntax highlighting, code fences, or any text outside the Java code.
                    - Your output must start immediately with public class ScanCheck { and must end after the closing }.
                    - Use the decoded probe when analysing the response
                    - When designing your isVulnerable method you should avoid using existing text in the response.
                    - Checking the response with less than 5 characters is unlikely to work. You should ensure your check is longer than 5 characters.
                    
                    //Your class uses the following interfaces:
                    public interface HttpResponse {
                        short statusCode();
                   
                        String reasonPhrase();
                    
                        List<Cookie> cookies();
                    
                        Cookie cookie(String var1);
                    
                        String cookieValue(String var1);
                    
                        boolean hasCookie(String var1);
                    
                        boolean hasCookie(Cookie var1);
                    
                        MimeType mimeType();
                    
                        MimeType statedMimeType();
                    
                        MimeType inferredMimeType();
                    
                        boolean hasHeader(HttpHeader var1);
                    
                        boolean hasHeader(String var1);
                    
                        boolean hasHeader(String var1, String var2);
                    
                        HttpHeader header(String var1);
                    
                        String headerValue(String var1);

                        List<HttpHeader> headers();
                    
                        String httpVersion();
                    
                        int bodyOffset();
                    
                        ByteArray body();
                    
                        String bodyToString();
                    
                        boolean contains(String var1, boolean var2);
                    
                        boolean contains(Pattern var1);
                    
                        ByteArray toByteArray();
                    
                        String toString();
                    }
                    
                    public interface HttpHeader {
                        String name();
                    
                        String value();
                    
                        String toString();
                    }
                    
                    public enum MimeType {
                        NONE("none"),
                        UNRECOGNIZED("unrecognized content"),
                        AMBIGUOUS("ambiguous"),
                        HTML("HTML"),
                        PLAIN_TEXT("plain text"),
                        CSS("CSS"),
                        SCRIPT("script"),
                        JSON("JSON"),
                        RTF("RTF"),
                        XML("XML"),
                        YAML("YAML"),
                        IMAGE_UNKNOWN("an unknown image type"),
                        IMAGE_JPEG("a JPEG image"),
                        IMAGE_GIF("a GIF image"),
                        IMAGE_PNG("a PNG image"),
                        IMAGE_BMP("a BMP image"),
                        IMAGE_TIFF("a TIFF image"),
                        IMAGE_SVG_XML("a SVG image"),
                        SOUND("sound"),
                        VIDEO("video"),
                        APPLICATION_FLASH("a flash object"),
                        APPLICATION_UNKNOWN("an unknown application type"),
                        FONT_WOFF("a WOFF font file"),
                        FONT_WOFF2("a WOFF2 font file"),
                        LEGACY_SER_AMF("");
                    
                        private final String description;
                    
                        private MimeType(String description) {
                            this.description = description;
                        }
                    
                        public String description() {
                            return this.description;
                        }
                    }
                    
                    public interface Cookie {
                        String name();
                    
                        String value();
                    
                        String domain();
                    
                        String path();
                    
                        Optional<ZonedDateTime> expiration();
                    }
                    
                    The Java class must have exactly this structure:
                    public class ScanCheck {
                        public boolean isVulnerable(HttpResponse response) {
                            // code to detect vulnerability here
                        }
                        public String getRequestProbe() {
                            return "exampleProbe123";
                            // You should return a probe that tests for this vulnerability.
                            // Note this should just be the payload
                            // The payload should emulate the original encoding
                        }
                        public String getShortDescription() {
                            // return a string that briefly describes the vulnerability class
                        }
                    }
                    """;
            String vulnerabilityPrompt = "";
            switch (vulnerabilityClass) {
                case Vulnerability.XSS -> {
                    vulnerabilityPrompt = """
                       - Note X-Xss-Protection response header is irrelevant now and is not used by any modern browser. You should not use it for any analysis.\n
                    """;
                }
                case Vulnerability.HTTP_RESPONSE_SPLITTING -> {
                    vulnerabilityPrompt = """
                        - Do not look inside parsed Cookie objects when searching for CRLFs.
                        - When looking for CSLFs used the response headers as a whole, you can use the following code to get all headers:
                          String allHeaders = response.toString().substring(0, response.bodyOffset);
                        \n
                    """;
                }
                case Vulnerability.SQLI -> {
                    vulnerabilityPrompt = """
                        - Avoid assuming all SQL injections are in parameters; consider HTTP headers or cookies too.
                        - Check for delayed responses or out-of-band interactions in blind injection scenarios.
                    """;
                }
                case Vulnerability.SSRF -> {
                    vulnerabilityPrompt = """
                        - Prefer checking raw request body and headers, not just parsed URL or destination.
                        - Watch for SSRF via DNS rebinding or open redirects as intermediary hops.
                    """;
                }
                case Vulnerability.CSRF -> {
                    vulnerabilityPrompt = """
                        - Do not assume that presence of a CSRF token means it's validated.
                        - Pay attention to CORS policies and cookies with SameSite=None; they may bypass CSRF protections.
                    """;
                }
                case Vulnerability.LFI -> {
                    vulnerabilityPrompt = """
                        - Inspect file-based APIs and URL parameters that touch the file system.
                        - Consider common wrapper bypasses like null byte truncation or directory normalization.
                    """;
                }
                case Vulnerability.RFI -> {
                    vulnerabilityPrompt = """
                        - Watch for file inclusion patterns using protocols like http:// or php://.
                        - Dynamic inclusion from query parameters or external sources is a red flag.
                    """;
                }
                case Vulnerability.IDOR -> {
                    vulnerabilityPrompt = """
                        - Check if authorization is enforced on object-level identifiers, not just authentication.
                        - Always test numeric and UUID-based resources for predictability or exposure.
                    """;
                }
                case Vulnerability.PATH_TRAVERSAL -> {
                    vulnerabilityPrompt = """
                        - Look for ../ sequences in paths and verify if server canonicalizes paths correctly.
                        - Check interactions with APIs that read/write from disk or ZIP/jar extraction.
                    """;
                }
                case Vulnerability.CLICKJACKING -> {
                    vulnerabilityPrompt = """
                        - Check for missing or misconfigured X-Frame-Options or CSP frame-ancestors headers.
                        - Hidden or off-screen iframes can still be used in some UIs; don't rely on visibility checks.
                    """;
                }
                case Vulnerability.COMMAND_INJECTION -> {
                    vulnerabilityPrompt = """
                        - Audit any concatenation or interpolation into shell/exec commands.
                        - Look for calls to Runtime.exec, ProcessBuilder, or OS shell wrappers with unsanitized input.
                    """;
                }
                case Vulnerability.WEB_CACHE_DECEPTION -> {
                    vulnerabilityPrompt = """
                        - Focus on URLs with misleading extensions (e.g., /profile.php/home.jpg).
                        - Caching of personalized pages with static-looking URLs is the core issue.
                    """;
                }
                case Vulnerability.OPEN_REDIRECT -> {
                    vulnerabilityPrompt = """
                        - Relative or absolute redirects should be checked for user-controlled values.
                        - Don't ignore URL fragments or base64 encoded redirection targets.
                    """;
                }
                case Vulnerability.HTTP_PARAMETER_POLLUTION -> {
                    vulnerabilityPrompt = """
                        - Check what happens when the same parameter key is repeated (e.g., ?user=1&user=2).
                        - Pay attention to backend frameworks' handling of multi-value parameters.
                    """;
                }
                case Vulnerability.TEMPLATE_INJECTION -> {
                    vulnerabilityPrompt = """
                        - Check template expressions in user-controlled fields (e.g., {{userInput}}).
                        - Different engines have different syntaxes—test accordingly (e.g., Jinja2, Freemarker, Thymeleaf).
                    """;
                }
                case Vulnerability.ACCOUNT_ENUMERATION -> {
                    vulnerabilityPrompt = """
                        - Compare login and password reset error messages and response timings.
                        - Differences in HTTP status codes or headers may leak user existence.
                    """;
                }
                case Vulnerability.BROKEN_ACCESS_CONTROL -> {
                    vulnerabilityPrompt = """
                        - Do not rely on UI elements to enforce access control; test APIs directly.
                        - Try privilege escalation by changing roles or accessing unauthorized resources.
                    """;
                }
                case Vulnerability.BROKEN_AUTHENTICATION -> {
                    vulnerabilityPrompt = """
                        - Analyze password reset, account recovery, and session persistence mechanisms.
                        - Test for weak password policies, credential stuffing, or multi-factor bypasses.
                    """;
                }
                case Vulnerability.BUSINESS_LOGIC_FLAW -> {
                    vulnerabilityPrompt = """
                        - Think like a user trying to abuse the workflow (e.g., skipping payment or approvals).
                        - There may not be code-level bugs; the issue is in misuse of legitimate flows.
                    """;
                }
                case Vulnerability.CORS_MISCONFIGURATION -> {
                    vulnerabilityPrompt = """
                        - Look for overly permissive Access-Control-Allow-Origin and credentials=true.
                        - Wildcard origins with allow-credentials are invalid but often misconfigured.
                    """;
                }
                case Vulnerability.DESERIALIZATION -> {
                    vulnerabilityPrompt = """
                        - Look for serialized data (Java, JSON, PHP) in cookies, body, or headers.
                        - Check for gadgets or deserialization sinks like readObject() or unserialize().
                    """;
                }
                case Vulnerability.EXPRESSION_INJECTION -> {
                    vulnerabilityPrompt = """
                        - Evaluate EL or OGNL injection opportunities in custom logic or templating.
                        - ${...} and #{} are common signs in Java stack-based injection surfaces.
                    """;
                }
                case Vulnerability.HOST_HEADER_INJECTION -> {
                    vulnerabilityPrompt = """
                        - Test how the app behaves with a custom Host header; especially in redirects or password reset emails.
                        - Look at X-Forwarded-Host and related headers in proxy setups.
                    """;
                }
                case Vulnerability.JWT_NONE_ALGORITHM -> {
                    vulnerabilityPrompt = """
                        - Check JWTs for 'alg' header set to 'none' or unsupported algorithms.
                        - Try stripping the signature or swapping algorithms and see if it's still accepted.
                    """;
                }
                case Vulnerability.LOGIC_ABUSE -> {
                    vulnerabilityPrompt = """
                        - Abuse application logic like discount stacking, quota resets, or forced race conditions.
                        - Often involves using legitimate features in unexpected sequences or volumes.
                    """;
                }
                case Vulnerability.PROTOTYPE_POLLUTION -> {
                    vulnerabilityPrompt = """
                        - Look for payloads that modify __proto__, constructor, or prototype keys in JSON objects.
                        - Impact is usually on client-side JavaScript, especially with deep merge operations.
                    """;
                }
                case Vulnerability.REDOS -> {
                    vulnerabilityPrompt = """
                        - Check for user input in regex patterns, especially with nested quantifiers.
                        - Time-based fuzzing can reveal catastrophic backtracking vulnerabilities.
                    """;
                }
                case Vulnerability.SESSION_FIXATION -> {
                    vulnerabilityPrompt = """
                        - See if session identifiers can be set via GET/POST and remain valid after login.
                        - A session should be regenerated on privilege elevation events like login.
                    """;
                }
                case Vulnerability.SESSION_MISMANAGEMENT -> {
                    vulnerabilityPrompt = """
                        - Check cookie flags: HttpOnly, Secure, SameSite.
                        - Test for session timeout, invalidation after logout, and reuse of old tokens.
                    """;
                }
            }

            AI ai = new AI();
            ai.setBypassRateLimit(true);
            ai.setSystemMessage(basePrompt + vulnerabilityPrompt + codePrompt);
            JSONObject requestJSON = new JSONObject();
            requestJSON.put("request", Utils.truncateRequest(request));
            JSONObject responseJSON = new JSONObject();
            responseJSON.put("response", Utils.truncateResponse(response));
            JSONObject baseValueJSON = new JSONObject();
            baseValueJSON.put("baseValue", baseParam.getString("value"));
            ai.setPrompt("Request:\n"+requestJSON+"\n\nResponse:\n"+responseJSON+"\n\nBase value:"+baseValueJSON);
            ai.setTemperature(1.0);
            String aiResponse = ai.execute();
            return compileScanCheck(imports + aiResponse);
        } catch (Throwable throwable) {
            StringWriter writer = new StringWriter();
            throwable.printStackTrace(new PrintWriter(writer));
            api.logging().logToError(writer.toString());
        }
        return null;
    }
    public static void check(HttpRequest request, HttpResponse response) {
        RepeatStrikeExtension.executorService.submit(() -> {
            if(!request.isInScope()) {
                JOptionPane.showMessageDialog(null, "This request is not in scope");
                return;
            }
            JSONObject param = IdentifyPayload.identify(request);
            if(param != null) {
                Object scanCheck = VulnerabilityAnalysis.analyse(param, request, response);

                if(scanCheck != null && isVulnerable(scanCheck, response)) {
                    api.logging().logToOutput("Found vulnerability. Now scanning proxy history.");
                    AnalyseProxyHistory.analyse(scanCheck, request);
                } else {
                    api.logging().logToOutput("No vulnerability found.");
                }
            }
        });
    }
}
