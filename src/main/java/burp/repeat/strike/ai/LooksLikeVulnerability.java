package burp.repeat.strike.ai;

import burp.api.montoya.http.message.requests.HttpRequest;
import burp.api.montoya.http.message.responses.HttpResponse;
import burp.repeat.strike.RepeatStrikeExtension;
import burp.repeat.strike.settings.InvalidTypeSettingException;
import burp.repeat.strike.settings.UnregisteredSettingException;
import org.json.JSONObject;

import java.io.PrintWriter;
import java.io.StringWriter;

import static burp.repeat.strike.RepeatStrikeExtension.api;

public class LooksLikeVulnerability {
    public static boolean didAttackWork(String request, String response) {
        try {
            boolean debugAi;
            try {
                debugAi = RepeatStrikeExtension.generalSettings.getBoolean("debugAi");
            } catch (UnregisteredSettingException | InvalidTypeSettingException e) {
                api.logging().logToError("Error loading settings:" + e);
                throw new RuntimeException(e);
            }
            AI ai = new AI();
            ai.setBypassRateLimit(true);
            ai.setSystemMessage("""
                        You are a web security expert.
                        You are going to be given a request and response.
                        Do not output markdown. Your response can only be "Yes" or "No".
                        Look at the request and response and determine if you think the request and response resulted in a vulnerability.
                        Return "Yes" or "No" if you think the attack worked.
                        """);

            ai.setPrompt("Request:\n"+request+"\n\nResponse:\n"+response);
            ai.setTemperature(1.0);
            if(debugAi) {
                api.logging().logToOutput("Sending information to the AI");
                api.logging().logToOutput(ai.getSystemMessage()+ai.getPrompt());
            }
            String aiResponse = ai.execute();
            if(debugAi) {
                api.logging().logToOutput("AI response:\n"+aiResponse);
            }
            if(aiResponse.trim().equalsIgnoreCase("Yes")) {
                return true;
            } else {
                return false;
            }
        } catch (Throwable throwable) {
            StringWriter writer = new StringWriter();
            throwable.printStackTrace(new PrintWriter(writer));
            api.logging().logToError(writer.toString());
        }
        return false;
    }
    public static void check(HttpRequest request, HttpResponse response, JSONObject param) {
        RepeatStrikeExtension.executorService.submit(() -> {
            if(LooksLikeVulnerability.didAttackWork(request.toString(), response.toString())) {
                AnalyseProxyHistory.analyse(param, request, response);
            }
        });
    }
}
